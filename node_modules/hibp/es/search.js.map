{"version":3,"sources":["../src/search.js"],"names":["breachedAccount","pasteAccount","search","account","breachOptions","Promise","all","test","then","breaches","pastes"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,mBAA5B;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDA,IAAMC,SAAS,SAATA,MAAS,CAACC,OAAD,EAAUC,aAAV;AAAA,MAAUA,aAAV;AAAUA,iBAAV,GAA0B,EAA1B;AAAA;;AAAA,SACbC,QAAQC,GAAR,CAAY,CACVN,gBAAgBG,OAAhB,EAAyBC,aAAzB,CADU,EAEV;AACA,YAAUG,IAAV,CAAeJ,OAAf,IAA0BF,aAAaE,OAAb,CAA1B,GAAkD,IAHxC,CAAZ,EAIGK,IAJH,CAIQ;AAAA,QAAEC,QAAF;AAAA,QAAYC,MAAZ;AAAA,WAAyB;AAC/BD,wBAD+B;AAE/BC;AAF+B,KAAzB;AAAA,GAJR,CADa;AAAA,CAAf;AAUA;;;;;;;;;;AAQA,eAAeR,MAAf","sourcesContent":["import breachedAccount from './breachedAccount';\nimport pasteAccount from './pasteAccount';\n\n/**\n * Fetches all breaches and all pastes associated with the provided account\n * (email address or username). Note that the remote API does not support\n * querying pastes by username (only email addresses), so in the event the\n * provided account is not a valid email address, only breach data is queried\n * and the \"pastes\" field of the resulting object will always be null. This is\n * exactly how searching via the current web interface behaves, which this\n * convenience method is designed to mimic.\n *\n * @param {string} account an email address or username\n * @param {Object} [breachOptions] a configuration object pertaining to\n * breach queries\n * @param {string} [breachOptions.domain] a domain by which to filter the\n * results (default: all domains)\n * @param {boolean} [breachOptions.truncate] truncate the results to only\n * include the name of each breach (default: false)\n * @returns {Promise} a Promise which resolves to an object containing a\n * \"breaches\" key (which can be null or an array of breach objects) and a\n * \"pastes\" key (which can be null or an array of paste objects), or rejects\n * with an Error\n * @example\n * search('foo')\n *   .then(data => {\n *     if (data.breaches || data.pastes) {\n *       // ...\n *     } else {\n *       // ...\n *     }\n *   })\n *   .catch(err => {\n *     // ...\n *   });\n * @example\n * search('nobody@nowhere.com', { truncate: true })\n *   .then(data => {\n *     if (data.breaches || data.pastes) {\n *       // ...\n *     } else {\n *       // ...\n *     }\n *   })\n *   .catch(err => {\n *     // ...\n *   });\n *\n * @see https://haveibeenpwned.com/\n * @alias module:search\n */\nconst search = (account, breachOptions = {}) =>\n  Promise.all([\n    breachedAccount(account, breachOptions),\n    // This email regex is garbage but it seems to be what the API uses:\n    /^.+@.+$/.test(account) ? pasteAccount(account) : null,\n  ]).then(([breaches, pastes]) => ({\n    breaches,\n    pastes,\n  }));\n\n/**\n * A module for searching all breach and paste data associated with a specific\n * account (email address or username).\n *\n * @module search\n * @example\n * import { search } from 'hibp';\n */\nexport default search;\n"],"file":"search.js"}